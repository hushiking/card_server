/**
 *
 * @author     richen
 * @copyright  Copyright (c) 2016 - <richenlin(at)gmail.com>
 * @license    MIT
 * @version    17/7/27
 */
const knex = require('knex');
const lib = require('think_lib');
const logger = require('think_logger');
const parser = require('./sqlbuilder.js');
const socket = require('./socket.js');

module.exports = class {
    constructor(config = {}) {
        this.config = config;
        // this.logSql = config.db_ext_config.db_log_sql || false;
        this.transTimes = 0; //transaction times

        this.knexClient = knex({
            client: 'mysql'
        });

        this.handel = null;
        this.parsercls = null;
    }

    /**
     * 
     * 
     * @returns 
     */
    connect() {
        if (this.handel) {
            return Promise.resolve(this.handel);
        }
        //读写分离配置
        if (this.config.db_ext_config.read_write && lib.isArray(this.config.db_host)) {
            let configMaster = {
                db_name: lib.isArray(this.config.db_name) ? this.config.db_name[0] : this.config.db_name,
                db_host: lib.isArray(this.config.db_host) ? this.config.db_host[0] : this.config.db_host,
                db_user: lib.isArray(this.config.db_user) ? this.config.db_user[0] : this.config.db_user,
                db_pwd: lib.isArray(this.config.db_pwd) ? this.config.db_pwd[0] : this.config.db_pwd,
                db_port: lib.isArray(this.config.db_port) ? this.config.db_port[0] : this.config.db_port,
                db_charset: this.config.db_charset,
                db_timeout: this.config.db_timeout,
                db_ext_config: this.config.db_ext_config
            };
            let configSlave = {
                db_name: lib.isArray(this.config.db_name) ? this.config.db_name[1] : this.config.db_name,
                db_host: lib.isArray(this.config.db_host) ? this.config.db_host[1] : this.config.db_host,
                db_user: lib.isArray(this.config.db_user) ? this.config.db_user[1] : this.config.db_user,
                db_pwd: lib.isArray(this.config.db_pwd) ? this.config.db_pwd[1] : this.config.db_pwd,
                db_port: lib.isArray(this.config.db_port) ? this.config.db_port[1] : this.config.db_port,
                db_charset: this.config.db_charset,
                db_timeout: this.config.db_timeout,
                db_ext_config: this.config.db_ext_config
            };
            return Promise.all([new socket(configMaster).connect(), new socket(configSlave).connect()]).then(cons => {
                this.handel = { RW: true };
                this.handel.master = cons[0];
                this.handel.slave = cons[1];
                return this.handel;
            });
        } else {
            this.handel = new socket(this.config).connect();
            return this.handel;
        }
    }

    /**
     * 
     * 
     * @returns 
     */
    close() {
        if (this.handel) {
            if (this.handel.RW) {
                this.handel.master && this.handel.master.close && this.handel.master.close();
                this.handel.slave && this.handel.slave.close && this.handel.slave.close();
            } else {
                this.handel.close && this.handel.close();
            }
        }
        this.handel = null;
        return Promise.resolve();
    }

    /**
     * 
     * 
     * @returns 
     */
    parsers() {
        if (this.parsercls) {
            return this.parsercls;
        }
        this.parsercls = new parser(this.config);
        return this.parsercls;
    }

    /**
     *
     * @param schemas
     * @param config
     */
    migrate(schemas, config) {
        if (lib.isEmpty(schemas) || lib.isEmpty(config)) {
            return Promise.resolve();
        }
        let tableName = schemas.table;
        return this.execute(this.knexClient.schema.dropTableIfExists(tableName).toString()).then(() => {
            let options = {
                method: 'MIGRATE',
                schema: schemas
            };
            return this.parsers().buildSql(this.knexClient.schema, config, options).then(sql => {
                if (/\n/.test(sql)) {
                    let temp = sql.replace(/\n/g, '').split(';'), ps = [];
                    temp.map(item => {
                        ps.push(this.execute(item));
                    });
                    return Promise.all(ps);
                }
                return this.execute(sql);
            });
        });
    }

    /**
     *
     * @param sql
     */
    query(sql) {
        if (lib.isEmpty(sql)) {
            return Promise.reject('SQL analytic result is empty');
        }
        let connection = {}, config = this.config;
        return this.connect().then(conn => {
            connection = conn.RW ? conn.slave : conn || {};
            let fn = lib.promisify(connection.query, connection);
            return fn(sql);
        }).then((rows = []) => {
            config.connectionLimit && connection.release();
            logger.info(sql);
            return rows;
        }).catch(err => {
            this.close();
            logger.error(sql);
            return Promise.reject(err);
        });

    }

    /**
     *
     * @param sql
     */
    execute(sql) {
        if (lib.isEmpty(sql)) {
            return Promise.reject('SQL analytic result is empty');
        }
        let connection = {}, config = this.config;
        return this.connect().then(conn => {
            connection = conn.RW ? conn.master : conn || {};
            let fn = lib.promisify(connection.query, connection);
            return fn(sql);
        }).then(data => {
            config.connectionLimit && connection.release();
            logger.info(sql);
            if (data.insertId) {
                return data.insertId;
            }
            return data.affectedRows || 0;
        }).catch(err => {
            this.close();
            logger.error(sql);
            return Promise.reject(err);
        });
    }

    /**
     *
     * @param tableName
     * @param sqlStr
     * @returns {*}
     */
    native(tableName, sqlStr) {
        if (lib.isEmpty(sqlStr)) {
            return Promise.reject('_OPERATION_WRONG_');
        }
        if ((/[&(--);]/).test(sqlStr)) {
            sqlStr = sqlStr.replace(/&/g, '&amp;').replace(/;/g, '').replace(/--/g, '&minus;&minus;');
        }
        if (sqlStr.indexOf(tableName) === -1) {
            return Promise.reject('table name error');
        }
        let ouputs = this.knexClient.raw(sqlStr).toSQL();
        if (lib.isEmpty(ouputs)) {
            return Promise.reject('SQL analytic result is empty');
        }
        let connection, config = this.config;
        return this.connect().then(conn => {
            connection = conn.RW ? conn.master : conn;
            let fn = lib.promisify(connection.query, connection);
            return fn(ouputs.sql, ouputs.bindings);
        }).then((rows = []) => {
            config.connectionLimit && connection.release();
            logger.info(ouputs.sql);
            return rows;
        }).catch(err => {
            this.close();
            logger.error(ouputs.sql);
            return Promise.reject(err);
        });
    }

    /**
     *
     * @returns {*}
     */
    startTrans() {
        if (this.transTimes === 0) {
            this.transTimes++;
            return this.execute('START TRANSACTION');
        }
        return Promise.resolve();
    }

    /**
     *
     * @returns {*}
     */
    commit() {
        if (this.transTimes > 0) {
            this.transTimes = 0;
            return this.execute('COMMIT').then(data => {
                this.close();
                return data;
            });
        }
        return Promise.resolve();
    }

    /**
     *
     * @returns {*}
     */
    rollback() {
        if (this.transTimes > 0) {
            this.transTimes = 0;
            return this.execute('ROLLBACK').then(data => {
                this.close();
                return data;
            });
        }
        return Promise.resolve();
    }

    /**
     * 添加一条数据
     * @param {[type]} data    [description]
     * @param {[type]} options [description]
     * @param int 返回插入的id
     */
    add(data, options = {}) {
        options.method = 'ADD';
        options.alias = undefined;
        let knexCls = this.knexClient.insert(data).from(options.table);
        return this.parsers().buildSql(knexCls, data, options).then(sql => {
            return this.execute(sql);
        }).then(result => {
            //
            return result;
        });
    }

    /**
     * 删除数据
     * @return {[type]} [description]
     */
    delete(options = {}) {
        options.method = 'DELETE';
        options.alias = undefined;
        let knexCls = this.knexClient.del().from(options.table);
        return this.parsers().buildSql(knexCls, options).then(sql => {
            return this.execute(sql);
        }).then(result => {
            //
            return result;
        });
    }

    /**
     * 更新数据
     * @return {[type]} [description]
     */
    update(data, options = {}) {
        options.method = 'UPDATE';
        options.alias = undefined;
        let knexCls = this.knexClient.update(data).from(options.table);
        return this.parsers().buildSql(knexCls, data, options).then(sql => {
            return this.execute(sql);
        }).then(result => {
            //
            return result;
        });
    }

    /**
     *
     * @param data
     * @param field
     * @param options
     */
    increment(data, field, options = {}) {
        options.method = 'UPDATE';
        options.alias = undefined;
        let knexCls = this.knexClient;
        if (data[field]) {
            knexCls = knexCls.increment(field, data[field]);
            delete data[field];
        }
        knexCls = knexCls.from(options.table);
        return this.parsers().buildSql(knexCls, data, options).then(sql => {
            return this.execute(sql);
        }).then(result => {
            //更新前置操作内会改变data的值
            if (!lib.isEmpty(data)) {
                this.update(data, options);
            }
            return result;
        });
    }

    /**
     *
     * @param data
     * @param field
     * @param options
     */
    decrement(data, field, options = {}) {
        options.method = 'UPDATE';
        options.alias = undefined;
        let knexCls = this.knexClient;
        if (data[field]) {
            knexCls = knexCls.decrement(field, data[field]);
            delete data[field];
        }
        knexCls = knexCls.from(options.table);
        return this.parsers().buildSql(knexCls, data, options).then(sql => {
            return this.execute(sql);
        }).then(result => {
            //更新前置操作内会改变data的值
            if (!lib.isEmpty(data)) {
                this.update(data, options);
            }
            return result;
        });
    }

    /**
     * 查询数据条数
     * @param field
     * @param options
     * @returns {*}
     */
    count(field, options = {}) {
        options.method = 'COUNT';
        options.limit = [0, 1];
        field = field || `${options.alias}.${options.pk}`;
        let knexCls = this.knexClient.count(`${field} AS count`).from(`${options.table} AS ${options.alias}`);
        return this.parsers().buildSql(knexCls, options).then(sql => {
            return this.query(sql);
        }).then(result => {
            if (lib.isArray(result)) {
                if (result[0]) {
                    return result[0].count ? (result[0].count || 0) : 0;
                } else {
                    return 0;
                }
            } else {
                return result.count || 0;
            }
        });
    }

    /**
     * 统计数据数量和
     * @param field
     * @param options
     * @returns {*}
     */
    sum(field, options = {}) {
        options.method = 'SUM';
        options.limit = [0, 1];
        field = field || `${options.alias}.${options.pk}`;
        let knexCls = this.knexClient.sum(`${field} AS sum`).from(`${options.table} AS ${options.alias}`);
        return this.parsers().buildSql(knexCls, options).then(sql => {
            return this.query(sql);
        }).then(result => {
            if (lib.isArray(result)) {
                if (result[0]) {
                    return result[0].sum ? (result[0].sum || 0) : 0;
                } else {
                    return 0;
                }
            } else {
                return result.sum || 0;
            }
        });
    }

    /**
     * 查询一条数据
     * @return 返回一个promise
     */
    find(options = {}) {
        options.method = 'SELECT';
        options.limit = [0, 1];
        let knexCls = this.knexClient.select().from(`${options.table} AS ${options.alias}`);
        return this.parsers().buildSql(knexCls, options).then(sql => {
            return this.query(sql);
        }).then(result => {
            //
            return result;
        });
    }

    /**
     * 查询数据
     * @return 返回一个promise
     */
    select(options = {}) {
        options.method = 'SELECT';
        let knexCls = this.knexClient.select().from(`${options.table} AS ${options.alias}`);
        return this.parsers().buildSql(knexCls, options).then(sql => {
            return this.query(sql);
        }).then(result => {
            //
            return result;
        });
    }

    /**
     * 入库前数据处理
     * @param data
     * @param type
     * @returns {*}
     * @private
     */
    validData(data, type) {
        let typeCase = { json: 1, array: 1 };
        if (!lib.isString(data) && typeCase[type]) {
            return JSON.stringify(data);
        }
        return data;
    }

    /**
     * 查询后数据处理
     * @param data
     * @param fields
     * @returns {*}
     * @private
     */
    parseData(data, fields) {
        let typeCase = { json: 1, array: 1 };
        if (lib.isArray(data)) {
            for (let [k, v] of data.entries()) {
                if (typeof v === 'object') {
                    for (let n in v) {
                        if (fields[n] && fields[n].type in typeCase) {
                            try {
                                v[n] = JSON.parse(v[n]);
                            } catch (e) { }
                        }
                    }
                }
            }
        } else if (typeof data === 'object') {
            for (let n in data) {
                if (fields[n] && fields[n].type in typeCase) {
                    try {
                        data[n] = JSON.parse(data[n]);
                    } catch (e) { }
                }
            }
        }
        return data;
    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} data 
     * @returns 
     */
    getHasOneRelation(config, options, rel, data) {
        if (lib.isEmpty(data) || lib.isEmpty(data[rel.fkey])) {
            //modify by lihao 需要返回一个promise
            return Promise.resolve({});
        }
        let model = new (rel.model)(config);
        let opt = { where: { [rel.rkey]: data[rel.fkey] } };
        if (!lib.isEmpty(rel.options)) {
            opt = lib.extend(rel.options, opt, true);
        }
        return model.find(opt);
    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} data 
     * @returns 
     */
    getHasManyRelation(config, options, rel, data) {
        if (lib.isEmpty(data) || lib.isEmpty(data[rel.primaryPk])) {
            //modify by lihao 需要返回一个promise
            return Promise.resolve([]);
        }
        let model = new (rel.model)(config);
        let opt = { where: { [rel.rkey]: data[rel.primaryPk] } };
        if (!lib.isEmpty(rel.options)) {
            opt = lib.extend(rel.options, opt, true);
        }
        return model.select(opt);
    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} data 
     * @returns 
     */
    getManyToManyRelation(config, options, rel, data) {
        if (lib.isEmpty(data) || lib.isEmpty(data[rel.primaryPk])) {
            //modify by lihao 需要返回一个promise
            return Promise.resolve([]);
        }
        let model = new (rel.model)(config);
        let rpk = model.getPk();
        let mapModel = new rel.mapModel(config);
        return mapModel.select({ where: { [rel.fkey]: data[rel.primaryPk] } }).then(result => {
            let keys = [];
            result.map(item => {
                item[rel.rkey] && keys.push(item[rel.rkey]);
            });
            return model.select(!lib.isEmpty(rel.options) ? lib.extend(rel.options, { where: { [rpk]: keys } }, true) : { where: { [rpk]: keys } });
        });

        //    let options = {
        //        table: schemas.table,
        //        name: mapName,
        //        join: [
        //            {from: `${rel.model.modelName}`, on: {[rel.rkey]: rpk}, field: rel.field, type: 'inner'}
        //        ],
        //        where: {
        //            [rel.fkey]: data[rel.primaryPk]
        //        }
        //    };
        //    //数据量大的情况下可能有性能问题
        //    let regx = new RegExp(`${rel.name}_`, "g");
        //    return model.select(options).then(result => {
        //        result = JSON.stringify(result).replace(regx, '');
        //        return JSON.parse(result);
        //    });

    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} result 
     * @param {any} relationData 
     * @param {any} postType 
     * @returns 
     */
    async postHasOneRelation(config, options, rel, result, relationData, postType) {
        if (lib.isEmpty(result) || lib.isEmpty(relationData)) {
            logger.warn('The main model\'s result is empty or the associated sub model\'s data is empty.');
            return Promise.resolve();
        }
        let model = new (rel.model)(config);
        let primaryModel = new (rel.primaryModel)(config);
        switch (postType) {
            case 'ADD':
                //子表插入数据
                let fkey = await model.add(relationData);
                //更新主表关联字段
                if (fkey) {
                    return primaryModel.update({ [rel.fkey]: fkey }, { where: { [rel.primaryPk]: result } });
                }
                break;
            case 'UPDATE':
                let condition = {}, keys = [];
                //子表主键数据存在
                if (relationData[rel.fkey]) {
                    condition[rel.rkey] = relationData[rel.fkey];
                }
                //限制只能更新关联数据
                let info = await primaryModel.field([rel.primaryPk]).select(options).catch(e => []);
                info.map(item => {
                    item[rel.primaryPk] && keys.push(item[rel.primaryPk]);
                });
                if (keys.length > 0) {
                    condition.in = { [rel.rkey]: keys };
                    return model.update(relationData, { where: condition });
                }
                break;
            default:
                break;
        }
        return Promise.resolve();
    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} result 
     * @param {any} relationData 
     * @param {any} postType 
     * @returns 
     */
    async postHasManyRelation(config, options, rel, result, relationData, postType) {
        if (lib.isEmpty(result) || !lib.isArray(relationData)) {
            logger.warn('The main model\'s result is empty or the associated sub model\'s data is not an array.');
            return Promise.resolve();
        }
        let model = new (rel.model)(config), rpk = model.getPk(), ps;
        switch (postType) {
            case 'ADD':
                ps = [];
                for (let [k, v] of relationData.entries()) {
                    //子表插入数据
                    v[rel.rkey] = result;
                    ps.push(model.add(v));
                }
                return Promise.all(ps);
                break;
            case 'UPDATE':
                let condition = {}, keys = []; ps = [];
                let primaryModel = new (rel.primaryModel)(config);
                //限制只能更新关联数据
                let info = await primaryModel.field([rel.primaryPk]).select(options).catch(e => []);
                info.map(item => {
                    item[rel.primaryPk] && keys.push(item[rel.primaryPk]);
                });
                if (keys.length > 0) {
                    condition.in = { [rel.rkey]: keys };
                    for (let [k, v] of relationData.entries()) {
                        //子表主键数据存在
                        if (v[rpk]) {
                            condition[rpk] = v[rpk];
                        }
                        ps.push(model.update(v, { where: condition }));
                    }
                }
                return Promise.all(ps);
                break;
            default:
                break;
        }
        return Promise.resolve();
    }

    /**
     * 
     * 
     * @param {any} config 
     * @param {any} options 
     * @param {any} rel 
     * @param {any} result 
     * @param {any} relationData 
     * @param {any} postType 
     * @returns 
     */
    async postManyToManyRelation(config, options, rel, result, relationData, postType) {
        if (lib.isEmpty(result) || !lib.isArray(relationData)) {
            logger.warn('The main model\'s result is empty or the associated sub model\'s data is not an array.');
            return Promise.resolve();
        }
        //子表主键
        let model = new (rel.model)(config), rpk = model.getPk();
        let mapModel = new (rel.mapModel)(config), ps;
        switch (postType) {
            case 'ADD':
                for (let [k, v] of relationData.entries()) {
                    //子表增加数据
                    let fkey = await model.add(v); ps = [];
                    //关系表增加数据,使用thenAdd
                    if (fkey) {
                        ps.push(mapModel.thenAdd({ [rel.fkey]: result, [rel.rkey]: fkey }, {
                            where: {
                                [rel.fkey]: result,
                                [rel.rkey]: fkey
                            }
                        }));
                    }
                }
                return Promise.all(ps);
                break;
            case 'UPDATE':
                let condition = {}, keys = []; ps = [];
                let primaryModel = new (rel.primaryModel)(config);
                //限制只能更新关联数据
                let info = await primaryModel.join([{
                    from: mapModel.modelName,
                    on: { [rel.primaryPk]: rel.fkey },
                    field: [rel.fkey, rel.rkey],
                    type: 'inner'
                }]).select(options);
                info.map(item => {
                    item[rel.rkey] && keys.push(item[rel.rkey]);
                });
                if (keys.length > 0) {
                    condition.in = { [rpk]: keys };
                    for (let [k, v] of relationData.entries()) {
                        //关系表两个外键都存在,更新关系表
                        if (v[rel.fkey] && v[rel.rkey]) {
                            //关系表增加数据,此处不考虑两个外键是否在相关表存在数据,因为关联查询会忽略
                            ps.push(mapModel.thenAdd({
                                [rel.fkey]: v[rel.fkey],
                                [rel.rkey]: v[rel.rkey]
                            }, { where: { [rel.fkey]: v[rel.fkey], [rel.rkey]: v[rel.rkey] } }));
                        } else {
                            //仅存在子表主键
                            if (v[rpk]) {
                                condition[rpk] = v[rpk];
                            }
                            //更新
                            ps.push(model.update(v, { where: condition }));
                        }
                    }
                }
                return Promise.all(ps);
                break;
            default:
                break;
        }
        return Promise.resolve();
    }
};